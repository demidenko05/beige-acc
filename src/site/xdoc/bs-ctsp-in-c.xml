<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

  <properties>
    <title>Beigesoft™. Type-safe programming complex programs in C.</title>
   </properties>

  <body>

<h4>Beigesoft™. Type-safe programming complex programs in C.</h4>

<p>This is about how to make complex programs in C in optimal way. Using C in this way to create complex applications seems to be more optimal than using OOP C++ language.</p>
<p>
This is also about programming "static" programs, i.e. that can be changed only during software update.
Such complex high-performance programs are suitable for working on a weak device like mobile phone.
For enterprise-like applications language like Java is the choice, because we can change and dynamically reload any service (e.g. a renderer (JSP)) on a never-stop enterprise application.
For LFSC static applications like media-player, dictionary C is the choice.
C is actually the most used language in a regular Linux distribution (kernel itself, glibc, system-d, dbus, glib, gtk, gimp...).
</p>
<p>
We should consider these facts for maximum type-safe approach in a C-program:
<ul>
  <li>there are libs and a client program that uses these libs</li>
  <li>a lib consists of data models and methods dedicated to work with these data models</li>
  <li>direct access to lib's data models (e.g. shape->x1=1.23) in client is a wrong approach, it must be used dedicated lib's methods for it</li>
  <li>by using different kind of methods and data models we can achieve any high-level programming approach (e.g. polymorphism) in type-safe way</li>
  <li>checking object's (data-model) type during runtime (it do all OOP languages, GLIB...) is never optimal approach</li>
  <li>by using different kind of type-safe approaches we can guarantee that a whole program is type-safe in COMPILE TIME, so checking object's type during runtime is redundant</li>
</ul>
</p>

  <h4>Example #1. Type-safe polymorphism in C.</h4>
<p>
There are drawable objects (shapes) - triangle, square, circle.
There is a pane to show (draw) these objects.
Any object has type-safe methods like <b>int SHAPE_draw(SHAPE*)</b> and <b>SHAPE *SHAPE_new(SHAPE_ARGS)</b> e.g.:
<pre style="white-space: pre-wrap;">
//statically allocated constructor:
#define TRIANGLE_CREATE(alias, p_x1, p_y1, p_x2, p_y2, p_x3, p_y3) Triangle alias = { .x1 = p_x1, .y1 = p_y1, .x2 = p_x2, .y2 = p_y2, .x3 = p_x3, .y3 = p_y3 };
//dynamically allocated constructor:
Triangle *triangle_new(int p_x1, int p_y1, int p_x2, int p_y2, int p_x3, int p_y3);
int triangle_draw(Triangle *p_trngl);
</pre>
Pane has two same-size (total) arrays of all type-unsafe pointers to drawable objects and their corresponding methods, i.e.:
<pre style="white-space: pre-wrap;">
typedef struct {
  int total;
  void **shapes;
  int(**drawers)(void*); //delegators to draw
} Pane;
</pre>
Pane has methods:
<pre style="white-space: pre-wrap;">
Pane *pane_new(int p_total_shapes);
int pane_free(Pain *p_pane);
int pain_draw_all(Pain *p_pane);
</pre>
Any drawable object has type-safe method to add itself into given pane, e.g.:
<pre style="white-space: pre-wrap;">
  int triangle_add_to_pane(Pane *p_pane, Triangle *p_trngl);
</pre>
Of course, the ONLY "type-unsafe" code is in self-adding shape into pane method, there we cast SHAPE*->void*. And ONLY such method may cause TYPE-UNSAFE error (e.g. triangle data is putted into index 3, but method is putted into index 4, so you fill face the famous error "segmentation fault"), that can be detected very easily in test phase.
Shapes and Pane are library. Client is a final program that uses ONLY lib's methods and macros and never access shape's data directly.
Client example:
<pre style="white-space: pre-wrap;">
...
include "triangle.h"
include "pane.h"
...
Pane *pane = pane_new(4);
//it should be used a macro instead to hide Pane type, e.g.: PANE_NEW(pane, 4)
//macro to statically allocate triangle (without malloc), this is impossible in Java:
TRIANGLE_CREATE(tr0, 1, 2, 3, 4, 5, 6);
triangle_add_to_pane(pane, &amp;tr0);
Triangle *tr1 = triangle_new(1, 2, 3, 4, 5, 6);
triangle_add_to_pane(pane, tr1);
Triangle *tr2 = triangle_new(11, 12, 13, 14, 15, 16);
triangle_add_to_pane(pane, tr2);
...
pane_draw_all(pane);
...
triangle_free(tr1);
pane_free(pane);
...
</pre>
So this polymorphism approach in C seems to be quite type-safe.
</p>

<p>
To save you time, you can download source code "bs-ctsp-in-c-1.0.tar.xz" from files folder in <a href="https://sourceforge.net/projects/bsplay/">https://sourceforge.net/projects/bsplay/</a>
Unpack it, then "make test".
</p>

<p>
We should also consider these approaches and facts for optimal programming (it also must be maximum readable in C and native (disassemble) code):
<ul>
  <li>using garbage collector seems to be non-optimal</li>
  <li>in most cases compiler's warnings are actually errors</li>
  <li>Java code style standard seems to be more readable, but variable aliases should be long and prefixed for debugging in native code (e.g. s_title - static title, sf_make_stuff1 - static file's method, triangle_new - public triangle's method, p_total - method's parameter)</li>
  <li>using only the best alternative, e.g. operator "? :" in Java code style considered to be hard to read, and "if" is preferred, so here "if" is also preferred to "switch"</li>
  <li>of course, every lib should be tested</li>
  <li>when you free an object, then GLIBC caches this memory, so additional caching seems to be redundant, i.e. you mark object as unused, then use it as new instead of creating with constructor</li>
  <li>source code should be well commented</li>
</ul>
</p>

<p>
Also for BS LFSC standard, an application's (statically upgraded, non-enterprise) interface should be GTK2 based and adapted for mobile view.
</p>

<h4>Rapid development in C</h4>
<p>You should noticed that many methods and static macro constructor should be generated automatically in the same way as getters and setters in OOP IDE, e.g:
<pre style="white-space: pre-wrap;">
//you should type only object's structure:
typedef struct {
  int x1; int y1; int x2; int y2; int x3; int y3;
} Trinagle;
//then you should point this object to IDE to create static macro constructor, set of methods prototypes here in header file and their implementations in C file.
//example of possible automatically-generated methods:
//dynamic instance constructors/destructors:
  //client will itself invoke free for object created by this constructor:
Triangle *triangle_new(int p_x1, int p_y1, int p_x2, int p_y2, int p_x3, int p_y3);
  //macro to hide Triangle type:
#define TRIANGLE_NEW(p_aliasp, p_x1, p_y1, p_x2, p_y2, p_x3, p_y3) Triangle *p_aliasp = triangle_new(p_x1, p_y1, p_x2, p_y2, p_x3, p_y3);
  //this creates app-scoped (life-time) object and puts it and free method into AppDestructor that will invoke all registered destructors;
Triangle *triangle_new_appd(AppDestructor *p_appd, p_x1, int p_y1, int p_x2, int p_y2, int p_x3, int p_y3);
//it can be generated a complex destructor, e.g.: free(p_pane->drawers) free(p_pane)
int triangle_free(Triangle *p_trng);
//getters/setters:
int triangle_get_x(Triangle *p_trng);
int triangle_set_x(Triangle *p_trng, int p_x);
...
</pre>
</p>

<p>
Participate to develop additional/optimal C programs for BS LFSC (Linux From Source Code) that is planned to be portable - desktop/tablet/mobile.
</p>
  </body>

</document>
