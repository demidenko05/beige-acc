<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

  <properties>
    <title>Beigesoft™. Type-safe programming complex applications in C.</title>
   </properties>

  <body>

<h4>Beigesoft™. Type-safe programming complex applications in C.</h4>

<p>This is about how to make complex programs in C in optimal way. Using C in this way to create complex applications seems to be more optimal than using OOP C++ language.</p>
<p>
This is also about programming "static" programs, i.e. that can be changed only during software update.
Such complex high-performance programs are suitable for working on a weak device like mobile phone.
For enterprise-like applications a language like Java is the choice, because we can change and dynamically reload any service (e.g. a renderer JSP) on a never-stop enterprise application.
For LFSC static applications like a media-player or a dictionary the C is the choice.
C is actually the most used language in a regular Linux distribution (kernel itself, glibc, system-d, dbus, glib, gtk, gimp, Java, Perl...).
</p>
<p>
We should consider these facts for maximum type-safe approach in a C-program:
<ul>
  <li>there are libs and a client program that uses these libs</li>
  <li>a lib consists of data models and methods dedicated to work with these data models</li>
  <li>direct access to lib's data models (e.g. shape->x1=1.23) in client is a wrong approach, it must be used dedicated lib's methods for it</li>
  <li>by using different kind of methods and data models we can achieve any high-level programming approach (e.g. polymorphism) in type-safe way</li>
  <li>checking object's (data-model) type during runtime (it do all OOP languages, GLIB...) is never optimal approach</li>
  <li>by using different kind of type-safe approaches we can guarantee that whole program is type-safe in COMPILE TIME, so checking object's type during runtime is redundant</li>
</ul>
</p>

  <h4>Example #1. Type-safe polymorphism in C.</h4>
<p>
There are drawable objects (shapes) - triangle, square, circle.
There is a pane to show (draw) these objects.
Any object has type-safe methods like <b>int SHAPE_draw(SHAPE*)</b> and <b>SHAPE *SHAPE_new(SHAPE_ARGS)</b> e.g.:
<pre style="white-space: pre-wrap;">
//statically allocated constructor:
#define TRIANGLE_CREATE(alias, p_x1, p_y1, p_x2, p_y2, p_x3, p_y3) Triangle alias = { .x1 = p_x1, .y1 = p_y1, .x2 = p_x2, .y2 = p_y2, .x3 = p_x3, .y3 = p_y3 };
//dynamically allocated constructor:
Triangle *triangle_new(int p_x1, int p_y1, int p_x2, int p_y2, int p_x3, int p_y3);
int triangle_draw(Triangle *p_trngl);
</pre>
Pane has two same-size (total) arrays of all type-unsafe pointers to drawable objects and their corresponding methods, i.e.:
<pre style="white-space: pre-wrap;">
typedef struct {
  int total;
  void **shapes;
  int(**drawers)(void*); //delegators to draw
} Pane;
</pre>
Pane has methods:
<pre style="white-space: pre-wrap;">
Pane *pane_new(int p_total_shapes);
int pane_free(Pain *p_pane);
int pain_draw_all(Pain *p_pane);
</pre>
Any drawable object has type-safe method to add itself into given pane, e.g.:
<pre style="white-space: pre-wrap;">
  int triangle_add_to_pane(Pane *p_pane, Triangle *p_trngl);
</pre>
Of course, the ONLY type-unsafe code is in a method that adds given shape into given pane. In this method we cast SHAPE*->void*. ONLY such methods may cause TYPE-UNSAFE error (e.g. triangle data is putted into index 3, but method is putted into index 4, so you will face the famous error "segmentation fault"), that can be detected very easily in the test phase.
Shapes and Pane are library. A client is a final program that uses ONLY lib's methods and macros and never access shape's data directly.
Example of a client:
<pre style="white-space: pre-wrap;">
...
include "triangle.h"
include "pane.h"
...
Pane *pane = pane_new(4);
//it should be used a macro instead to hide Pane type, e.g.: PANE_NEW(pane, 4)
//macro to statically allocate triangle (without malloc), this is impossible in Java:
TRIANGLE_CREATE(tr0, 1, 2, 3, 4, 5, 6);
triangle_add_to_pane(pane, &amp;tr0);
Triangle *tr1 = triangle_new(1, 2, 3, 4, 5, 6);
triangle_add_to_pane(pane, tr1);
Triangle *tr2 = triangle_new(11, 12, 13, 14, 15, 16);
triangle_add_to_pane(pane, tr2);
...
pane_draw_all(pane);
...
triangle_free(tr1);
pane_free(pane);
...
</pre>
So this polymorphism approach in C seems to be quite type-safe.
</p>

<p>
To save you time, you can download source code "bs-tsp-in-c-1.0.tar.xz" from files folder in <a href="https://sourceforge.net/projects/bsplay/">https://sourceforge.net/projects/bsplay/</a>
Unpack it, then "make test".
</p>

<p>
  <h4>Comparing approaches for polymorphism-like tasks, e.g. "draw_all()"</h4>
  <table>
    <tr>
      <th>Approach</th>
      <th>Result</th>
    </tr>
    <tr>
      <td>C without polymorphism</td>
      <td>Totally type-safe, high performance, large lib's code, nice client's code (in case of using encapsulation-like methods)</td>
    </tr>
    <tr>
      <td>C with polymorphism described above</td>
      <td>Practically type-safe, highest performance, smaller lib's code, nice client's code</td>
    </tr>
    <tr>
      <td>C with OOP-like lib, e.g. GLIB</td>
      <td>Type-safe only on run-time, high performance, small lib's code, there are a lot of objects casting in client's code</td>
    </tr>
    <tr>
      <td>OOP-language, e.g. C++</td>
      <td>Totally(practically) type-safe, lowest performance, smallest lib's code, client's code often(in practice) consist of type-unsafe generics, e.g. in Java "Map&lt;String, Object&gt; params"</td>
    </tr>
  </table>
</p>

<p>
  <h4>Other  approaches for optimal programming in C</h4>
We should also consider these approaches and facts for optimal programming (it also must be maximum readable in C and native (disassemble) code):
<ul>
  <li>using garbage collector seems to be non-optimal</li>
  <li>in most cases compiler's warnings are actually errors</li>
  <li>using the most used in the universe part-assembly approach, an assembly can be a part of another assembly</li>
  <li>part(of lib - single h and c file) is minimum composite, there are not cross(mutual)-dependencies between parts in whole lib</li>
  <li>of course, every lib should be tested</li>
  <li>when you free an object, then GLIBC caches this memory, so additional caching seems to be redundant, i.e. you mark object as unused, then use it as new instead of creating with constructor</li>
  <li>Java code style standard seems to be more readable, but variable aliases should be long and prefixed for debugging in native code (e.g. s_title - static title, sf_make_stuff1 - static file's method, triangle_new - public triangle's method, p_total - method's parameter)</li>
  <li>the simpler the better</li>
  <li>the more straight-full meaning the better, e.g. use "if (object_pointer != NULL)" instead of "if (object_pointer)", also use "if (is_ok)" only when "is_ok" may have TRUE(1) or FALSE(0) values...</li>
  <li>use only the best alternative, e.g. operator "? :" in Java code style considered to be hard to read, and "if" is preferred, so here "if" is also preferred to "switch"</li>
  <li>source code should be well commented</li>
</ul>
</p>

<p>
Also for BS LFSC standard, an application's (statically upgraded, non-enterprise) interface should be GTK2 based and adapted for mobile view.
</p>

<h4>Rapid development in C, other examples.</h4>
<p>You should noticed that many methods and static macro constructor should be generated automatically in the same way as getters and setters in OOP IDE, e.g:
<pre style="white-space: pre-wrap;">
//you should type only object's structure:
typedef struct {
  int x1; int y1; int x2; int y2; int x3; int y3;
} Triangle;
//then you should point this object to IDE to create static macro constructor, set of methods prototypes here in header file and their implementations in C file.
//example of possible automatically-generated methods:
//dynamic instance constructors/destructors:
  //client will itself invoke free for object created by this constructor:
Triangle *triangle_new(int p_x1, int p_y1, int p_x2, int p_y2, int p_x3, int p_y3);
  //macro to hide Triangle type:
#define TRIANGLE_NEW(p_aliasp, p_x1, p_y1, p_x2, p_y2, p_x3, p_y3) Triangle *p_aliasp = triangle_new(p_x1, p_y1, p_x2, p_y2, p_x3, p_y3);
  //this creates app-scoped (life-time) object and puts it and free method into AppDestructor that will invoke all registered destructors;
Triangle *triangle_new_appd(AppDestructor *p_appd, p_x1, int p_y1, int p_x2, int p_y2, int p_x3, int p_y3);
//it can be generated a complex destructor, e.g.: free(p_pane->drawers) free(p_pane)
int triangle_free(Triangle *p_trng);
//getters/setters:
int triangle_get_x1(Triangle *p_trng);
int triangle_set_x1(Triangle *p_trng, int p_x1);
...
</pre>
Also, Pane should better has type-unsafe method like:
<pre style="white-space: pre-wrap;">
//it's also thread-safe method, i.e. it locks (synchronizes) those pointers arrays during invocation
int pane_add_shape_tus(Pane *p_pane, void *p_shape, Draw_Gen_Tus *p_drawer);
</pre>
This method must be wrapped be type-safe method in any shape.
So, making type-unsafe generic methods and data, then wrap them (implement) with type-safe ones is good approach for many tasks, e.g. iterator+consumer:
<pre style="white-space: pre-wrap;">
//file Record.h
//type-safe data:
...
typedef struct {...} Record;

//type-unsafe methods and data:
typedef int Record_Consumer_Tus(Record *p_rec, void *p_instrument);

int file_iterate_all_tus(FILE *p_file, Record_Consumer_Tus *p_rec_csm, void *p_instrument);
...

//file RecordMax.h
//all type-safe including wrappers:
...
typedef struct {...} RecordMaxInst;

//an implementation can be wrapped by another type-safe implementation (interceptor), e.g. for debugging/testing
typedef int Record_Consumer_Max(Record *p_rec, RecordMaxInst *p_instrument);
...

//file RecordMax.c
int file_iterate_all_max(FILE *p_file, Record_Consumer_Max *p_rec_csm, RecordMaxInst *p_instrument) {
//some preparation:
...
  file_iterate_all_tus(p_file, (Record_Consumer_Tus*) p_rec_csm, (void*) p_instrument); //only type-unsafe entry
//some finishing:
...
}
</pre>
Standard lib also should be wrapped, it makes more easy life for client, e.g.:
<pre style="white-space: pre-wrap;">
int fwrite_long_int(FILE *p_file, long int *p_data) { //type safe wrapper
  return fwrite(p_data, sizeof(long int), 1, p_file);
}
</pre>

</p>

<p>
Participate to develop additional/optimal C programs for BS LFSC (Linux From Source Code) that is planned to be portable - desktop/tablet/mobile.
</p>
  </body>

</document>
