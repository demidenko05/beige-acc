<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

  <properties>
    <title>Beigesoft™. Type-safe programming complex applications in C.</title>
   </properties>

  <body>

<h4>Beigesoft™. Type-safe programming complex applications in C.</h4>

<p>This is about how to make complex programs in C in optimal way. Using C in this way to create complex applications seems to be more optimal than using OOP C++ language.</p>
<p>
This is also about programming "static" programs, i.e. that can be changed only during software update.
Such complex high-performance programs are suitable for working on a weak device like mobile phone.
For financial-like applications Java with WEB-interface is the choice, because we can change and dynamically reload any service (e.g. a renderer JSP) on a never-stop enterprise application,
and there is cross-platform WEB-app server A-Jetty.
For LFSC static applications like a media-player or a dictionary the C is the choice.
C is actually the most used language in a regular Linux distribution (kernel itself, glibc, system-d, dbus, glib, gtk, gimp, Java, Perl, etc. are written with C).
</p>
<p>
We should consider these facts for maximum type-safe approach in a C-program:
<ul>
  <li>there are libs and a client program that uses these libs</li>
  <li>a lib consists of data models and methods dedicated to work with these data models</li>
  <li>sometime direct access to lib's data models (e.g. shape->x1=1.23) is a wrong approach, e.g. when argument maybe wrong</li>
  <li>by using different kind of methods and data models we can achieve any high-level programming approach (e.g. polymorphism) in type-safe way</li>
  <li>checking object's (data-model) type during runtime (it do all OOP languages, GLIB...) is never optimal approach</li>
  <li>by using different kind of type-safe approaches we can guarantee that whole program is type-safe in COMPILE TIME, so checking object's type during runtime is redundant</li>
  <li>it's all about finding gold mean between pure C-style (highest performance, but sometimes brutal and type-unsafe) and OOP-like (less error-able, more readable) approach</li>
</ul>
</p>

  <h4>Example #1. Type-safe polymorphism in C.</h4>
<p>
There are drawable objects (shapes) - triangle, square, circle.
There is a pane to show (draw) these objects.
Any object has type-safe methods like <b>int SHAPE_draw(SHAPE*)</b> and <b>SHAPE *SHAPE_new(SHAPE_ARGS)</b> e.g.:
<pre style="white-space: pre-wrap;">
//statically allocated constructor:
#define TRIANGLE_CREATE(alias, p_x1, p_y1, p_x2, p_y2, p_x3, p_y3) Triangle alias = { .x1 = p_x1, .y1 = p_y1, .x2 = p_x2, .y2 = p_y2, .x3 = p_x3, .y3 = p_y3 };
//dynamically allocated constructor:
Triangle *triangle_new(int p_x1, int p_y1, int p_x2, int p_y2, int p_x3, int p_y3);
int triangle_draw(Triangle *p_trngl);
</pre>
Pane has two same-size (total) arrays of all type-unsafe pointers to drawable objects and their corresponding methods, i.e.:
<pre style="white-space: pre-wrap;">
typedef struct {
  int total;
  void **shapes;
  int(**drawers)(void*); //delegators to draw
} Pane;
</pre>
Pane has methods:
<pre style="white-space: pre-wrap;">
Pane *pane_new(int p_total_shapes);
int pane_free(Pain *p_pane);
int pain_draw_all(Pain *p_pane);
</pre>
Any drawable object has type-safe method to add itself into given pane, e.g.:
<pre style="white-space: pre-wrap;">
  int triangle_add_to_pane(Pane *p_pane, Triangle *p_trngl);
</pre>
Of course, the ONLY type-unsafe code is in the method that adds given shape into given pane. In this method we cast SHAPE*->void*. ONLY such methods may cause TYPE-UNSAFE error (e.g. triangle data is putted into index 3, but method is putted into index 4, so you will face the famous error "segmentation fault"), that can be detected very easily in the test phase.
Shapes and Pane are library. A client is a final program that uses ONLY lib's methods and macros and never access shape's data directly.
Example of a client:
<pre style="white-space: pre-wrap;">
...
include "triangle.h"
include "pane.h"
...
Pane *pane = pane_new(4);
//it should be used a macro instead to hide Pane type, e.g.: PANE_NEW(pane, 4)
//macro to statically allocate triangle (without malloc), this is impossible in Java:
TRIANGLE_CREATE(tr0, 1, 2, 3, 4, 5, 6);
triangle_add_to_pane(pane, &amp;tr0);
Triangle *tr1 = triangle_new(1, 2, 3, 4, 5, 6);
triangle_add_to_pane(pane, tr1);
Triangle *tr2 = triangle_new(11, 12, 13, 14, 15, 16);
triangle_add_to_pane(pane, tr2);
...
pane_draw_all(pane);
...
triangle_free(tr1);
pane_free(pane);
...
</pre>
So this polymorphism approach in C seems to be quite type-safe.
</p>

<p>
To save you time, you can download source code "bs-tsp-in-c-1.0.tar.xz" from files folder in <a href="https://sourceforge.net/projects/bsplay/">https://sourceforge.net/projects/bsplay/</a>
Unpack it, then "make test".
</p>

<p>
  <h4>Comparing approaches for polymorphism-like tasks, e.g. "draw_all()"</h4>
  <table>
    <tr>
      <th>Approach</th>
      <th>Result</th>
    </tr>
    <tr>
      <td>C without polymorphism (in case of using type-safe encapsulation-like methods)</td>
      <td>Totally type-safe, high performance, large lib's code, nice client's code</td>
    </tr>
    <tr>
      <td>C with polymorphism described above</td>
      <td>Practically type-safe, highest performance, smaller lib's code, nice client's code</td>
    </tr>
    <tr>
      <td>C with OOP-like lib, e.g. GLIB</td>
      <td>Type-safe only on run-time, high performance, small lib's code, there are a lot of objects casting in client's code</td>
    </tr>
    <tr>
      <td>OOP-language, e.g. C++</td>
      <td>Totally(practically) type-safe, lowest performance, smallest lib's code, client's code often(in practice) consist of type-unsafe generics, e.g. in Java "Map&lt;String, Object&gt; params"</td>
    </tr>
  </table>
</p>

<p>
  <h4>Other  approaches for optimal programming in C</h4>
We should also consider these approaches and facts for optimal programming (it also must be maximum readable in C and native (disassemble) code):
<ul>
  <li>using garbage collector seems to be non-optimal, it should be methods to detect non-freed objects (program mistake) during checking sources files. Crashing is another problem.</li>
  <li>in most cases compiler's warnings are actually errors</li>
  <li>using the most used in the universe part-assembly approach, an assembly can be a part of another assembly</li>
  <li>part(of lib - single h and c file) is minimum composite, there are not cross(mutual)-dependencies between parts in whole lib</li>
  <li>of course, every lib should be tested</li>
  <li>when you free an object, then GLIBC caches this memory, so additional caching seems to be redundant, i.e. you mark object as unused, then use it as new instead of creating with constructor</li>
  <li>the simpler the better</li>
  <li>the more straight-full meaning the better, e.g. use "if (object_pointer != NULL)" instead of "if (object_pointer)", also use "if (is_ok)" only when "is_ok" may have TRUE(1) or FALSE(0) values, etc. Also names(aliases) of data(variables) and methods should be straightly-meanings, e.g. triangle_free(p_trngl) means just free memory and nulling pointers, but object_destroy(p_obj) means free memory and additional things like closing object's files (this helps to understand code more quickly without looking comments).</li>
  <li>use only the best alternative, e.g. operator "? :" in Java code style considered to be hard to read, and "if" is preferred, so here "if" is also preferred to "switch"</li>
  <li>source code should be well commented</li>
  <li>a lot of methods should be public only for testing purpose</li>
  <li>GDB should be used when "seg-fault" or a test fails and adding new sub-tests or validators and logging seems to be excessive.</li>
</ul>
Rules "the simpler the better", "use only the best alternative" and "the more straight-full meaning the better" say that creating and using static (allocating) constructors in the above example (draw_all) is wrong approach.
</p>
<p>
Rules above and testing obey to decrease possible errors, ability to fix them more easy and faster, so as a result programming complex application in C is never complicated than do it in high level languages like Java.
</p>
<p>
Also for BS LFSC standard, an application's (statically upgraded, non-enterprise) interface should be GTK2 based and adapted for mobile view.
</p>

<h4>Code style</h4>
<p>
  This is about how to make code's words more distinct (actually more faster recognized/perceived by brain). There are facts:
  <ul>
    <li>In practice short aliases (variables, functions, etc. names) look better in code (exactly in code's lines, i.e. inside methods, not in data definitions).</li>
    <li>object's member's name "len" is better (in code) than "length"</li>
    <li>Spacing make code more readable. This is not only about inside line spaces, it's also about spaces between lines.</li>
    <li>Vertical spaces is useful not only because of using upper-case macro. It's needed because of small monospace-fonts line spacing (actually glyph's height).</li>
    <li>The more spaces inside line, the more longer line, i.e. it become less readable.</li>
    <li>Distinct rules about naming words of different types and spacing improve readability, e.g. lower prefix "p" in method's arguments, "if ( i = 1 )" vs "a = s_method1 (45);" .</li>
    <li>type name "DataSet" is better than "struct data_set". Non-struct data types (hardly ever used) should be prefixed.</li>
    <li>type name "Compare_Tus*" is better than "int (*compare)(void*,void*)".</li>
  </ul>
  So, code should be spaced by spaces themselves and with shorting names. Naming and spacing should be distinct(different) depending of their subject.
  <p>Code style should be like this:</p>
  <ul>
    <li>Horizontal off-start space (indentation) is 2 spaces, and big ('vary to avoid making long line) for split line's 2-nd parts (except method's "return type - name" line)</li>
    <li>Vertical spacing is made of line with only brace (open/close block), empty line, and sometime with huge horizontal indentation (spacing) of 2-nd part[s] of a split line (in case of short next line)</li>
    <li>Vertical spacing made of empty line is optional</li>
    <li>Vertical spacing is optional for short methods</li>
    <li>Types names start with upper cases.</li>
    <li>methods and their types names are highlighted with "_", static ones should be prefixed with "s_"</li>
    <li>variables never use "_", but use upper-cases letters after start, e.g. sTimer - static timer, pX1 - argument, bufSz - automatic var, .bufSize or better .bsize - member in an object.</li>
    <li>Macro's names use upper-case letters with "_".</li>
    <li>Enum values are same as macro names, except them should be prefixed with "E"</li>
    <li>Debug lines can be long</li>
  </ul>
</p>

<h4>Type-safe wrappers.</h4>
<p>
Pane should better has type-unsafe method like:
<pre style="white-space: pre-wrap;">
//it's also thread-safe method, i.e. it locks (synchronizes) those pointers arrays during invocation
int pane_add_shape_tus(Pane *p_pane, void *p_shape, Draw_Gen_Tus *p_drawer);
</pre>
This method must be wrapped be type-safe method in any shape.
So, making type-unsafe generic methods and data, then wrap them (implement) with type-safe ones is a good approach for many tasks, e.g. iterator+consumer:
<pre style="white-space: pre-wrap;">
//file Record.h
//type-safe data:
...
typedef struct {...} Record;

//type-unsafe methods and data:
typedef int Rec_Consume_Tus(Record *pRec, void *pInstr);

int file_iterate_tus (FILE *pFile, Rec_Consume_Tus *pRecCsm, void *pInstr);
...

//file RecordMax.h
//all type-safe including wrappers:
...
typedef struct {...} RecordMax;

//an implementation can be wrapped by another type-safe implementation (interceptor), e.g. for debugging/testing
typedef int Rec_Consume_Max(Record *p_rec, RecordMax *pInstr);
...

//file RecordMax.c
int
  file_iterate_max (FILE *pFile, Rec_Consume_Max *pRecCsm, RecordMax *pInstr)
{
//some preparation:
...
  file_iterate_tus (pFile, (Rec_Consume_Tus*) pRecCsm, (void*) pInstr); //only type-unsafe entry
//some finishing:
...
}
</pre>
Standard lib should also be wrapped, it makes more easy life for a client, e.g.:
<pre style="white-space: pre-wrap;">
//type safe wrapper:
int
  fwrite_long (FILE *pFile, long int *pData)
{
  return fwrite (pData, sizeof(long int), 1, pFile);
}
</pre>
Also autotools seems to be useless. Just add new file (and its test) into Makefile during making huge application step by step (file by file).
Make allows enough flexible behavior,  e.g.:
<pre style="white-space: pre-wrap;">
libs=alsa sdl2
ifeq ($(shell pkg-config libass &amp;&amp; echo $$?),0)
  libs += libass
endif
//or from file created according user's preferences:
libs = $(shell cat libs.conf)
</pre>
</p>

<h4>Errors handling and reporting</h4>
<p>Here errors mean "program's errors". Errors types:
  <ul>
    <li>program's checkable errors, e.g. NULL pointer when it's not allowed, index outside of array, wrong pointer outside dedicated to it segment, etc.</li>
    <li>program's non-checkable errors, e.g. bad pointer inside dedicated to it segment, string non-initialized with zero terminator and passed to "strlen", etc.</li>
    <li>out of order errors, e.g. out of memory, network connection is broken, disk full, etc.</li>
  </ul>
</p>
<p>Even though there is no "often changed business logic", errors sometimes happen in regular C applications.
The best approach to handle and report errors should be like this:
<ul>
  <li>any method that can cause an error must set thread scoped variable "errno" and log error</li>
  <li>any subsequent-back method (that invokes errorable method) should check errno, and handle - i.e. it should log to track whole backtrace</li>
  <li>a file is the best alternative to report any error</li>
</ul>
So, example is:
<pre style="white-space: pre-wrap;">
//Data set lib Types:
...
#define BSDATASET(pSetType) BS_IDX_T bsize; BS_IDX_T size; pSetType **vals;

typedef struct {
  BSDATASET(void)
} BsDataSetTus;

typedef void BsVoid_Method(void);

typedef struct {
  BSDATASET(BsVoid_Method)
} BsVoidMeths;

#define BSLOG_ERR bslog_log(BSLERROR, "%s:%s:%d\n", __FILE__, __func__, __LINE__);

void
  bsdatasettus_remove_shrink (BsDataSetTus *pSet, BS_IDX_T pIdx)
{
  if ( pIdx &lt; BS_IDX_0 || pIdx &gt;= pSet-&gt;size )
  {
    errno = BSE_ARR_OUT_OF_BOUNDS;
    BSLOG_ERR
    return;
  }
  pSet-&gt;vals[pIdx] = NULL;
  for ( BS_IDX_T l = pIdx + BS_IDX_1; l &lt; pSet-&gt;size; l++ )
  {
    pSet-&gt;vals[l - BS_IDX_1] = pSet-&gt;vals[l];
  }
  pSet-&gt;size--;
}

//Just type-safe wrapper:
void
  bsvoidmeths_remove_shrink (BsVoidMeths *pSet, BS_IDX_T pIdx)
{
  bsdatasettus_remove_shrink ((BsDataSetTus*) pSet, pIdx);
}

//Error propagation generic macro:
#define BS_DO_E_OUT(p_invoked) p_invoked;\
  if (errno != 0) { BSLOG_ERR goto out; }
...

//CLIENT's sub-lib: error propagation:
static int sCount = 0;

static void
  s_void_meth1 (void)
{
  sCount++;
}

static void
  s_test1 ()
{
  //it will return error on hardly ever possible ENOMEM:
  BSVOIDMETHS_NEW_E_RET (arr, 2L) //size=2

  //increase=2 when full-filled:
  BS_DO_E_OUT (bsvoidmeths_add_inc (arr, &amp;s_void_meth1, 2))

  BS_DO_E_OUT (bsvoidmeths_add_inc (arr, &amp;s_void_meth1, 2))

  //it will increase size or hardly ever possible ENOMEM:
  BS_DO_E_OUT (bsvoidmeths_add_inc (arr, &amp;s_void_meth1, 2))

  bsvoidmeths_invoke_all (arr); //sCount must be 3

  BS_DO_ERR (bsvoidmeths_remove_shrink (arr, 4L)) //ERROR! 4 &gt; (size-1)=3

out:
  bsvoidmeths_free(arr);
}
//Main client:
int
  main (int argc, char *argv[])
{
  ...
  s_test1 (); //must be BSE_ARR_OUT_OF_BOUNDS
  if ( errno != 0 )
  {
    //report to user and stay working
    //or finishing (free memory and closing files) and exiting:
    ...
  }
  //normal steps:
  ...
//back-trace report will be:
02/08/20 13:59:06.367 thread#140432137471744 ERROR: Out of bounds
  BsDataSet.c:bsdatasettus_remove_shrink:498
02/08/20 13:59:06.367 thread#140432137471744 ERROR: Out of bounds
  tst_BsDataSet.c:s_test1:67
</pre>
But this approach can't catch real happen error e.g. "Segmentation fault".
GLIBC utility "catchsegv" allows to track these errors by hand. But GDB is the best alternative, just use "backtrace" or "bt".
To automatically report backtrace, use same named GLIBC method (execinfo.h), "open" file descriptor (fcntl.h) and "backtrace_symbols_fd" (see "debug" folder in GLIBC source).
Alternatively, to record into own log file, you can use only "backtrace" method to get addresses, and it's seems enough (i.e. printing only method's addresses).
Or make new method based on "backtrace_symbols/-fd" or to avoid using malloc or FD.
So, after interception "SIGABRT" or similar errors, free resources and close files, then print stack-trace. To obtain the line in source code by address from report use command:
<pre style="white-space: pre-wrap;">
addr2line -e [program_file] [address1] [address2]
//e.g.:
addr2line -e tst_1 0x401da1 0x404d11
</pre>
</p>
<p>
GLIBC's backtrace (actually GCC's _Unwind_Backtrace) can't work when cause is "wrong method's address", and so does "catchsegv" (it can print only registers dump). GDB can do it.
So, if you got empty report, then see "bad pointers" to methods (use GDB). Anyway segmentation fault cause wrong method's pointer happen very seldom (used in code).
</p>
<p>
  Using brutal "C-signals" plus printing backtrace (even only with methods addresses) may seem to be the best alternative to handle exactly program's errors.
  Because of program's errors should happen hardly ever, and never on production build (in theory, but not in practice).
  That is use "raise(SIGABRT)" plus well-logging or just "assert([condition])" to abort and report into stderr this condition.
</p>
<p>In other hand, GLIB uses such excessive error checking and propagation without termination (checking for type, if parameter is NULL).
This allows to more accurately handle and report error, to keep program working, so user can use other error-less functionality.
So program's errors are treated as "part of functionality is out of order".
Also, using "C-signals" requires additional coding to pass all destructors.
In case of excessive error handling using macro can decrease coding (see example above).
</p>
<p>Standard C-lib also treat part of exactly program's errors as non-fatal.
E.g. "stdio.seek" will not abort if you point outside of a file, it just return error code.
But "strlen" on NULL pointer will cause segmentation fault, instead of checking and returning error (or setting thread-local "errno" code).</p>
<p>
  So, additional (sometime may seem excessive) work like:
  <ul>
    <li>Making methods to operate objects with additional checking</li>
    <li>Making type-safe wrappers</li>
    <li>Making type-safe libs with macro-wrappers to allow clients to be tiny and totally type-safe at compile time</li>
    <li>Testing</li>
    <li>Logging (including debug)</li>
    <li>Excessive error checking and handling</li>
  </ul>
  are considered as useful here for Beigesoft standard. They obey to decrease errors, to detect and fix them more faster.
</p>
<p>*Such excessive things are called "fault tolerance" in "reliability engineering".</p>
<p>
  To avoid excessive double checking(validation) use well known phases:
  <ol>
    <li>Object creating/initializing (and filling) with validation</li>
    <li>Object further modification with validation</li>
    <li>Object using (without modification and double validation)</li>
  </ol>
  Although GLIB/GTK use excessive double checking, they are really fast.
</p>

<h4>Using excessive checking in destructors</h4>
<p>In this case, code becames more simple and readable, and IDE can generate automatically complex constructors and part of methods.</p>
<p>
Constructor standard style example:
<pre style="white-space: pre-wrap;">
BsLogFiles*
  bslogfiles_new (int pSize)
{
  if ( pSize &lt; 1 ) {
    errno = BSE_ARR_WPSIZE;
    fprintf (stderr, "%s %s\n", __func__, bserror_to_str(errno));
    return NULL;
  }
  BsLogFiles *obj = malloc (sizeof (BsLogFiles));
  if ( obj == NULL )
  {
    if ( errno == 0 ) { errno = ENOMEM; }
    perror (__func__);
    return NULL;
  }
  obj-&gt;files = malloc (pSize * sizeof (BsLogFile*));
  if (obj-&gt;files == NULL)
                      { goto err1; }
  obj-&gt;size = pSize;
  int i;
  for ( i = 0; i &lt; obj-&gt;size; i++ )
  {
    obj-&gt;files[i] = NULL;
  }
  for ( i = 0; i &lt; obj-&gt;size; i++ )
  {
    obj-&gt;files[i] = malloc(sizeof(BsLogFile));
    if (obj-&gt;files[i] == NULL)
                      { goto err2; }
    obj-&gt;files[i]-&gt;file = NULL;
    obj-&gt;files[i]-&gt;path = NULL;
  }
  return obj;
err2:
  for ( i = 0; i &lt; obj-&gt;size; i++ )
  {
    if ( obj-&gt;files[i] != NULL )
                      { free (obj-&gt;files[i]); }
  }
  free (obj-&gt;files);
err1:
  free (obj);
  if ( errno == 0 ) { errno = ENOMEM; }
  perror (__func__);
  return NULL;
}
</pre>
Constructor/destructor with excessive checking example:
<pre style="white-space: pre-wrap;">
BsLogFiles*
  bslogfiles_new (int pSize)
{
  if ( pSize &lt; 1 )
  {
    errno = BSE_ARR_WPSIZE;
    fprintf (stderr, "%s %s\n", __func__, bserror_to_str(errno));
    return NULL;
  }
  BsLogFiles *obj = malloc (sizeof (BsLogFiles));
  if ( obj == NULL )
  {
    if ( errno == 0 ) { errno = ENOMEM; }
    perror (__func__);
    return NULL;
  }
  obj-&gt;files = malloc (pSize * sizeof (BsLogFile*));
  if ( obj-&gt;files == NULL )
  {
    obj = bslogfiles_free (obj);
    goto out;
  }
  obj-&gt;size = pSize;
  int i;
  for ( i = 0; i &lt; obj-&gt;size; i++ )
  {
    obj-&gt;files[i] = NULL;
  }
  for ( i = 0; i &lt; obj-&gt;size; i++ )
  {
    obj-&gt;files[i] = malloc (sizeof (BsLogFile));
    if ( obj-&gt;files[i] == NULL )
    {
      obj = bslogfiles_free (obj);
      break;
    }
    obj-&gt;files[i]-&gt;file = NULL;
    obj-&gt;files[i]-&gt;path = NULL;
  }
out:
  if ( obj == NULL )
  {
    if ( errno == 0 ) { errno = ENOMEM; }
    perror (__func__);
  }
  return obj;
}
//Destructor with excessive checking that always return NULL:
BsLogFiles*
  bslogfiles_free (BsLogFiles *pLogFls)
{
  if ( pLogFls != NULL ) {
    if ( pLogFls-&gt;files != NULL ) {
      for ( int i = 0; i &lt; pLogFls-&gt;size; i++ ) {
        if ( pLogFls-&gt;files[i]-&gt;file != NULL ) {
          fprintf (pLogFls-&gt;files[i]-&gt;file, "BS-LOG try to close...\n");
          fclose (pLogFls-&gt;files[i]-&gt;file);
        }
        if ( pLogFls-&gt;files[i]-&gt;path != NULL ) {
          free (pLogFls-&gt;files[i]-&gt;path);
        }
        free (pLogFls-&gt;files[i]);
      }
      free (pLogFls-&gt;files);
    }
    free (pLogFls);
  }
  return NULL;
}
</pre>
Method using constructors/destructors with excessive checking example (this part can be generated by IDE):
<pre style="white-space: pre-wrap;">
void
  method1 (void)
{
  OBJECTTYPE0_NEW_ERR_RET (ot0)

  ObjectType1 ot1 = NULL;
  ObjectType2 ot2 = NULL;
  ObjectType3 ot3 = NULL;

  INVOKE_ERR_OUT (ot1 = objecttype1_new())

  INVOKE_ERR_OUT (ot2 = objecttype2_new())

  INVOKE_ERR_OUT (ot3 = objecttype3_new())
  ...
out:
  objecttype0_free (ot0);
  objecttype1_free (ot1);
  objecttype2_free (ot2);
  objecttype3_free (ot3);
}
</pre>
</p>
<p>In this case destructor is more reusable and code looks more readable, less error-able, patternable, simple and similar for many use-cases.</p>

<p>
Participate to develop additional/optimal C programs for BS LFSC (Linux From Source Code) that is planned to be portable - desktop/tablet/mobile.
</p>
  </body>

</document>
