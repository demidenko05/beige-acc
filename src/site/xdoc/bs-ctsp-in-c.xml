<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

  <properties>
    <title>Beigesoft™. Type-safe programming complex applications in C.</title>
   </properties>

  <body>

<h4>Beigesoft™. Type-safe programming complex applications in C.</h4>

<p>This is about how to make complex programs in C in optimal way. Using C in this way to create complex applications seems to be more optimal than using OOP C++ language.</p>
<p>
This is also about programming "static" programs, i.e. that can be changed only during software update.
Such complex high-performance programs are suitable for working on a weak device like mobile phone.
For enterprise-like applications a language like Java is the choice, because we can change and dynamically reload any service (e.g. a renderer JSP) on a never-stop enterprise application.
For LFSC static applications like a media-player or a dictionary the C is the choice.
C is actually the most used language in a regular Linux distribution (kernel itself, glibc, system-d, dbus, glib, gtk, gimp, Java, Perl, etc. are written with C).
</p>
<p>
We should consider these facts for maximum type-safe approach in a C-program:
<ul>
  <li>there are libs and a client program that uses these libs</li>
  <li>a lib consists of data models and methods dedicated to work with these data models</li>
  <li>direct access to lib's data models (e.g. shape->x1=1.23) in client is a wrong approach, it must be used dedicated lib's methods for it</li>
  <li>by using different kind of methods and data models we can achieve any high-level programming approach (e.g. polymorphism) in type-safe way</li>
  <li>checking object's (data-model) type during runtime (it do all OOP languages, GLIB...) is never optimal approach</li>
  <li>by using different kind of type-safe approaches we can guarantee that whole program is type-safe in COMPILE TIME, so checking object's type during runtime is redundant</li>
</ul>
</p>

  <h4>Example #1. Type-safe polymorphism in C.</h4>
<p>
There are drawable objects (shapes) - triangle, square, circle.
There is a pane to show (draw) these objects.
Any object has type-safe methods like <b>int SHAPE_draw(SHAPE*)</b> and <b>SHAPE *SHAPE_new(SHAPE_ARGS)</b> e.g.:
<pre style="white-space: pre-wrap;">
//statically allocated constructor:
#define TRIANGLE_CREATE(alias, p_x1, p_y1, p_x2, p_y2, p_x3, p_y3) Triangle alias = { .x1 = p_x1, .y1 = p_y1, .x2 = p_x2, .y2 = p_y2, .x3 = p_x3, .y3 = p_y3 };
//dynamically allocated constructor:
Triangle *triangle_new(int p_x1, int p_y1, int p_x2, int p_y2, int p_x3, int p_y3);
int triangle_draw(Triangle *p_trngl);
</pre>
Pane has two same-size (total) arrays of all type-unsafe pointers to drawable objects and their corresponding methods, i.e.:
<pre style="white-space: pre-wrap;">
typedef struct {
  int total;
  void **shapes;
  int(**drawers)(void*); //delegators to draw
} Pane;
</pre>
Pane has methods:
<pre style="white-space: pre-wrap;">
Pane *pane_new(int p_total_shapes);
int pane_free(Pain *p_pane);
int pain_draw_all(Pain *p_pane);
</pre>
Any drawable object has type-safe method to add itself into given pane, e.g.:
<pre style="white-space: pre-wrap;">
  int triangle_add_to_pane(Pane *p_pane, Triangle *p_trngl);
</pre>
Of course, the ONLY type-unsafe code is in the method that adds given shape into given pane. In this method we cast SHAPE*->void*. ONLY such methods may cause TYPE-UNSAFE error (e.g. triangle data is putted into index 3, but method is putted into index 4, so you will face the famous error "segmentation fault"), that can be detected very easily in the test phase.
Shapes and Pane are library. A client is a final program that uses ONLY lib's methods and macros and never access shape's data directly.
Example of a client:
<pre style="white-space: pre-wrap;">
...
include "triangle.h"
include "pane.h"
...
Pane *pane = pane_new(4);
//it should be used a macro instead to hide Pane type, e.g.: PANE_NEW(pane, 4)
//macro to statically allocate triangle (without malloc), this is impossible in Java:
TRIANGLE_CREATE(tr0, 1, 2, 3, 4, 5, 6);
triangle_add_to_pane(pane, &amp;tr0);
Triangle *tr1 = triangle_new(1, 2, 3, 4, 5, 6);
triangle_add_to_pane(pane, tr1);
Triangle *tr2 = triangle_new(11, 12, 13, 14, 15, 16);
triangle_add_to_pane(pane, tr2);
...
pane_draw_all(pane);
...
triangle_free(tr1);
pane_free(pane);
...
</pre>
So this polymorphism approach in C seems to be quite type-safe.
</p>

<p>
To save you time, you can download source code "bs-tsp-in-c-1.0.tar.xz" from files folder in <a href="https://sourceforge.net/projects/bsplay/">https://sourceforge.net/projects/bsplay/</a>
Unpack it, then "make test".
</p>

<p>
  <h4>Comparing approaches for polymorphism-like tasks, e.g. "draw_all()"</h4>
  <table>
    <tr>
      <th>Approach</th>
      <th>Result</th>
    </tr>
    <tr>
      <td>C without polymorphism (in case of using type-safe encapsulation-like methods)</td>
      <td>Totally type-safe, high performance, large lib's code, nice client's code</td>
    </tr>
    <tr>
      <td>C with polymorphism described above</td>
      <td>Practically type-safe, highest performance, smaller lib's code, nice client's code</td>
    </tr>
    <tr>
      <td>C with OOP-like lib, e.g. GLIB</td>
      <td>Type-safe only on run-time, high performance, small lib's code, there are a lot of objects casting in client's code</td>
    </tr>
    <tr>
      <td>OOP-language, e.g. C++</td>
      <td>Totally(practically) type-safe, lowest performance, smallest lib's code, client's code often(in practice) consist of type-unsafe generics, e.g. in Java "Map&lt;String, Object&gt; params"</td>
    </tr>
  </table>
</p>

<p>
  <h4>Other  approaches for optimal programming in C</h4>
We should also consider these approaches and facts for optimal programming (it also must be maximum readable in C and native (disassemble) code):
<ul>
  <li>using garbage collector seems to be non-optimal, it should be methods to detect non-freed objects (program mistake) during checking sources files. Crashing is another problem.</li>
  <li>in most cases compiler's warnings are actually errors</li>
  <li>using the most used in the universe part-assembly approach, an assembly can be a part of another assembly</li>
  <li>part(of lib - single h and c file) is minimum composite, there are not cross(mutual)-dependencies between parts in whole lib</li>
  <li>of course, every lib should be tested</li>
  <li>when you free an object, then GLIBC caches this memory, so additional caching seems to be redundant, i.e. you mark object as unused, then use it as new instead of creating with constructor</li>
  <li>Java code style standard seems to be more readable, but variable aliases should be long and prefixed for debugging in native code (e.g. s_title - static title, sf_make_stuff1 - static file's method, triangle_new - public triangle's method, p_total - method's parameter)</li>
  <li>the simpler the better</li>
  <li>the more straight-full meaning the better, e.g. use "if (object_pointer != NULL)" instead of "if (object_pointer)", also use "if (is_ok)" only when "is_ok" may have TRUE(1) or FALSE(0) values, etc. Also names(aliases) of data(variables) and methods should be straightly-meanings, e.g. triangle_free(p_trngl) means just free memory and nulling pointers, but object_free_clsf(p_obj) means free memory and close object's files (this helps to understand code more quickly without looking comments).</li>
  <li>use only the best alternative, e.g. operator "? :" in Java code style considered to be hard to read, and "if" is preferred, so here "if" is also preferred to "switch"</li>
  <li>source code should be well commented</li>
  <li>a lot of methods should be public only for testing purpose</li>
  <li>in practice, using debug logging together with testing is more efficient (faster) than use a debugger (even with testing).</li>
</ul>
Rules "the simpler the better", "use only the best alternative" and "the more straight-full meaning the better" say that creating and using static (allocating) constructors in the above example (draw_all) is wrong approach.
</p>
<p>
Rules above and testing obey to decrease possible errors, ability to fix them more easy and faster, so as a result programming complex application in C is never complicated than do it in high level languages like Java.
In opposite to Java, long names (aliases) in C never cause increasing stripped binary files size.
</p>

<p>
Also for BS LFSC standard, an application's (statically upgraded, non-enterprise) interface should be GTK2 based and adapted for mobile view.
</p>

<h4>Rapid development in C, other examples.</h4>
<p>You should noticed that many methods and static macro constructor should be generated automatically in the same way as getters and setters in OOP IDE, e.g:
<pre style="white-space: pre-wrap;">
//you should type only object's structure:
typedef struct {
  int x1; int y1; int x2; int y2; int x3; int y3;
} Triangle;
//then you should point this object to IDE to create static macro constructor, set of methods prototypes here in header file and their implementations in C file.
//example of possible automatically-generated methods:
//dynamic instance constructors/destructors:
  //client will itself invoke free for object created by this constructor:
Triangle *triangle_new(int p_x1, int p_y1, int p_x2, int p_y2, int p_x3, int p_y3);
  //macro to hide Triangle type:
#define TRIANGLE_NEW(p_aliasp, p_x1, p_y1, p_x2, p_y2, p_x3, p_y3) Triangle *p_aliasp = triangle_new(p_x1, p_y1, p_x2, p_y2, p_x3, p_y3);
  //this creates app-scoped (life-time) object and puts it and free method into AppDestructor that will invoke all registered destructors;
Triangle *triangle_new_appd(AppDestructor *p_appd, p_x1, int p_y1, int p_x2, int p_y2, int p_x3, int p_y3);
//it can be generated a complex destructor, e.g.: free(p_pane->drawers) free(p_pane)
int triangle_free(Triangle *p_trng);
//getters/setters:
int triangle_get_x1(Triangle *p_trng);
int triangle_set_x1(Triangle *p_trng, int p_x1);
...
</pre>
Also, Pane should better has type-unsafe method like:
<pre style="white-space: pre-wrap;">
//it's also thread-safe method, i.e. it locks (synchronizes) those pointers arrays during invocation
int pane_add_shape_tus(Pane *p_pane, void *p_shape, Draw_Gen_Tus *p_drawer);
</pre>
This method must be wrapped be type-safe method in any shape.
So, making type-unsafe generic methods and data, then wrap them (implement) with type-safe ones is a good approach for many tasks, e.g. iterator+consumer:
<pre style="white-space: pre-wrap;">
//file Record.h
//type-safe data:
...
typedef struct {...} Record;

//type-unsafe methods and data:
typedef int Record_Consumer_Tus(Record *p_rec, void *p_instrument);

int file_iterate_all_tus(FILE *p_file, Record_Consumer_Tus *p_rec_csm, void *p_instrument);
...

//file RecordMax.h
//all type-safe including wrappers:
...
typedef struct {...} RecordMaxInst;

//an implementation can be wrapped by another type-safe implementation (interceptor), e.g. for debugging/testing
typedef int Record_Consumer_Max(Record *p_rec, RecordMaxInst *p_instrument);
...

//file RecordMax.c
int file_iterate_all_max(FILE *p_file, Record_Consumer_Max *p_rec_csm, RecordMaxInst *p_instrument) {
//some preparation:
...
  file_iterate_all_tus(p_file, (Record_Consumer_Tus*) p_rec_csm, (void*) p_instrument); //only type-unsafe entry
//some finishing:
...
}
</pre>
Standard lib should also be wrapped, it makes more easy life for a client, e.g.:
<pre style="white-space: pre-wrap;">
int fwrite_long_int(FILE *p_file, long int *p_data) { //type safe wrapper
  return fwrite(p_data, sizeof(long int), 1, p_file);
}
</pre>
Also autotools seems to be useless. Just add new file (and its test) into Makefile during making huge application step by step (file by file).
Make allows enough flexible behavior,  e.g.:
<pre style="white-space: pre-wrap;">
libs=alsa sdl2
ifeq ($(shell pkg-config libass &amp;&amp; echo $$?),0)
  libs += libass
endif
//or from file created according user's preferences:
libs = $(shell cat libs.conf)
</pre>
</p>
<h4>Errors handling and reporting</h4>
<p>It's like handling exceptions in Java.
Even though there is no "often changed business logic", errors sometimes happen in regular C applications.
Simple approach to handle and report errors can be like this:
<ul>
  <li>any method that can cause an error must return Error object</li>
  <li>if an error occurred, then non-NULL Error object consists of initial error code and all error messages array</li>
  <li>this non-NULL Error object will be propagated from first error occurrence to the thirst invoker(main program) with adding information about error and all invokers</li>
  <li>a file is the best alternative to report an error</li>
</ul>
So, example is:
<pre style="white-space: pre-wrap;">
//first error occurrence:
Error *arrayint_set(ArrayInt *p_array, int p_idx, int p_value) {
  if (p_idx &lt; 0 || p_idx &gt;= p_array->size) {
    return bserror_new(ARR_ERR_OUT_OF_BOUNDS, "arrayint_set");
  }
  p_array->array[p_idx] = p_value;
  return NULL;
}
//error propagation:
Error *invoker_im() {
  ...
  ARRAYINT_NEW(arr, 11)
  Error *err = arrayint_set(arr, 12, 3); //12 > 10max
  if (err != NULL) {
    error_propagate(err, "invoker_im");
  } else {
    ...
  }
  arrayint_free(arr);
  return err;
}
//final client handles the error:
int main(int argc, char *argv[]) {
  ...
  Error *err = invoker_im();
  if (err != NULL) {
    int errcode = err->code;
    error_report_free(err, "top client"); //it will also free error
    //finishing (free memory and closing files) and exiting:
    ...
    return errcode;
  }
  //normal steps:
  ...
</pre>
But this approach can't catch real happen error e.g. "Segmentation fault".
GLIBC utility "catchsegv" allows to track these errors by hand. But GDB is the best alternative, just use "backtrace" or "bt".
To automatically report backtrace, use same named GLIBC method (execinfo.h), "open" file descriptor (fcntl.h) and "backtrace_symbols_fd" (see "debug" folder in GLIBC source).
Alternatively, to record into own log file, you can use only "backtrace" method to get addresses, and it's seems enough (i.e. printing only method's addresses).
Or make new mathod based on "backtrace_symbols/-fd" or to avoid using malloc or FD.
So, after interception "SIGABRT" or similar errors, free resources and close files, then print stack-trace. To obtain the line in source code by address from report use command:
<pre style="white-space: pre-wrap;">
addr2line -e [program_file] [address1] [address2]
//e.g.:
addr2line -e tst_1 0x401da1 0x404d11
</pre>
GLIBC's backtrace (actually GCC's _Unwind_Backtrace) can't work when cause is "wrong method's address", and so does "catchsegv" (it can print only registers dump). GDB can do it.
So, if you got empty report, then see "bad pointers" to methods (use GDB).
</p>
<p>
  Method with making object "Error" is not more helpful than "C-signals" plus printing backtrace (even only methods addresses).
  And it requires more coding than sending error signal.
  So, "C-signals" is the best alternative.
</p>

<p>
Participate to develop additional/optimal C programs for BS LFSC (Linux From Source Code) that is planned to be portable - desktop/tablet/mobile.
</p>
  </body>

</document>
