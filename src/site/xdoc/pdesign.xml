<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

  <properties>
    <title>Beigesoft™. Programming approaches.</title>
   </properties>

  <body>

  <h3>Beigesoft™. Programming approaches.</h3>

  
  <b>Key words: Design principles, OOP patterns.</b>
  
  <p>This is about the main point of "how to design a program in optimal way".
  All these approaches are widely used in the real life. So this is also about "get back from newest terms(words) to old ones".
  </p>
  <h4>1. Part - assembly approach. A part should be as atomic as possible. An assembly can consist of other assemblies (parts).</h4>
  <p>Real life example: a gear, an engine, an atom, a quark, etc.</p>
  <p>OOP principles and patterns that follow to this approach:
    <ul>
      <li>Interface Segregation Principle (ISP): Clients should not be forced to depend upon interfaces that they don't use.</li>
      <li>Single Responsibility Principle. This principle states that if we have 2 reasons to change for a class, we have to split the functionality in two classes.</li>
      <li>POJO - as a pure atomic data model</li>
    </ul>
    OOP means "encapsulation", so in the old days programmers often filled "Objects" as much as possible, what is why those OOP design patterns came about. 
  </p>
  
  <p>You can look at https://github.com/demidenko05/beige-uml source that is very good example of "part-assemble" approach.
    There an UML element is a full assemble (OOP) that includes all methods - invoking form (editor), draw, move, resize, etc. And this final assembly is made by final concrete platform-dependent factory, i.e. SWING and AWT or Android. Cross-platform logic parts include: element form editor, resize-movement service, etc.
    <ul>
      take a look at their source sizes(without tests sources):
      <li>cross-platform libs (basic logic of editors, factories, drawers, etc):  beige-lib=180.3 KiB; beige-uml-base=1.1 MiB.</li>
      <li>platform-dependent libs (final implementations of editors, drawers, etc):  beige-swing-lib=41.4 KiB; beige-android-lib=92.5 KiB.</li>
      <li>final assemblies:  beige-uml-android=493.1 KiB; beige-uml-swing=559.5 KiB.</li>
      So, the basic cross-platform parts are the largest.
    </ul>
  </p>

  <h4>Common violations of "part-assembly" approach.</h4>
  <p>1. OOP itself requires that an object must encapsulate of methods. In C we can create object String{char *val; int len;}, then, WHEN IT'S NEEDED, we can create StringObject{String *val; int (*printer)(char*);}.
  As a result, programmers often prefer to use functional style in OOP language, because it's more easy and inexpensive. Remarkable example is Hibernate in Java.
  </p>
  <p>2. Runtime annotations in Java. Assume you want to add JAXB for an object that is already an annotated JPA entity. At first, you violate OCP and have to recompile this class. At second, mixing JAXB and JPA annotations is definitely looks no good and might not work.
  You can look at Beige-EIS code, where for example DebtorCreditor entity has 4 different XML configurations: 1 - ORM, 2 - WEB FORM/LIST generator, 3 - full database copy via XML WEB-service, 4 - export from tax to financial database via XML WEB-service.
  So a configuration of how to use a class in a library (ORM, ...) is exactly another part that must be placed in a its own place (file).
  </p>

  <h4>2. Interface or Abstraction of a part. This allows to make an assembly from parts by attaching via an interface (abstraction). So you can fix or change an assembly by substitution a part.</h4>
  <p>Real life example: an engine is connected to a transmission via a generic junction (interface), so you can choice between AT/MT4/MT6.</p>
  <p>Functional programming - headers in C (public methods and data types). An interface can use super-abstractions such as void* pointers.</p>
  <p>OOP. In Java there is exactly "interface" type of file. You should use Abstract classes only to inherit properties and methods for extending classes, and abstract classes usually should implements interface/s.</p>
  <p>Example of high level abstraction interface between Shapes and Pane with methods encapsulation in C: Shape{int startX; int startY;} and ShapeObj{Shape *shape, void (*draw)(Shape*);}. In Java this is: IShape {int getStartX(); int getStartY(); void setStartX(int x); void setStartY(int y); void draw();} </p>
  <p>
    OOP principles and patterns that follow to this approach: 
    <ul>
      <li>
        Dependency Inversion Principle. High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.
      </li>
    </ul>
  </p>
  <p>In Java, an interface should be used only when it's needed by a client. For example in Beige EIS DebtorCreditor has generic interfaces - IHasID, IHasVersion, IHasName, but methods "get/set TIN" are only this class's methods, because there is no a client that expects generic interface with this methods.</p>
  
  <h4>3. An interface of a part must follow the client (assembly) expectations, i.e. interface must be implemented in straightforward (non-ambiguous) meaning, especially on case of substitutions of parts.</h4>
  <p>Real life examples:
    <ul>
      Ambiguous:
      <li>"charged" bank account VS "charged" atomic particle</li>
    </ul>
    <ul>
      Properly:
      <li>A transmission implementation must follow the engine specification - i.e. its power, torque, etc.</li>
    </ul>
    </p>
  <p>
    Programming - interface must be implemented in straightforward way, without confusing a client (assembly).
    In case when a part is substituted by another one that has another meaning interface implementation, then already worked assembly might not work properly.
  </p>
  <p>
    OOP principles and patterns that follow to this approach: 
    <ul>
      <li>
        Likov's Substitution Principle states that if a program module is using a Base class, then the reference to the Base class can be replaced with a Derived class without affecting the functionality of the program module. The article (https://www.oodesign.com/liskov-s-substitution-principle.html) provides an example: the interface "setHeight(int heihgt)" of the "Rectangle" was implemented in other-meaning way "setHeight(int heihgtAndWidth)" for the "Square" that confuses the client.
      </li>
    </ul>
  </p>
  
  <h4>Triple: the simple the better; use the best alternative; the more tests the better.</h4>
  <p>If a part is satisfied to all of the requirements, then this is a reason to use it, and there is no reason to substitute it, except experimental or innovation purposes.</p>
  <p>When you save time by using already working parts in a new assembly, then you have more time for testing.</p>
  <p>Real life example: the same bearing has been used for many years in many countries in car engines, in wheel hubs, etc.</p>
  <p>Software architects sometime choose creating new own parts for the only reason - they must be totally ours. Maybe it's a company politic - no advertising of free software.</p>
  <p>Part of Java EE: servlets, JSP (WEB-server) are the best alternative not only for WEB-interface. Even JSP is best mean to make JSON responses (see in Beige-EIS payment gateway response RESTFUL).
  With servlets you can easy make any thing - RESTFUL API, XML, PDF... In the old time Spring MVC overcame EJB because of the best performance. But it was actually JEE - WEB part. Automatically filling of a model from a request - isn't a big deal.
  In Beige-EIS WEB-store buyers requests processed by hand. Of course, it's used Beige-WEB for making the catalog, prices, etc. And Beige-WEB isn't only for automatically filling of models, it also allow ta make reliable WEB-interface really quickly (almost automatically).
  </p>
  
  
  <p>References:
  <ul>
    <li>https://www.oodesign.com</li>
  </ul>
  </p>
  
  
  </body>

</document>
